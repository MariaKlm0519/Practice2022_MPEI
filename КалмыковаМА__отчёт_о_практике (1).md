![](Aspose.Words.e549a3a3-f587-4cf7-9d8f-be9183044b9a.001.jpeg)

**СОДЕРЖАНИЕ ОТЧЕТА** 

График прохождения практики ........................................................................... 3 

1. Описание профильной организации .............................................................. 4 
1. Результаты выполнения индивидуального задания ...................................... 5 Список литературы ............................................................................................ 14 

![](Aspose.Words.e549a3a3-f587-4cf7-9d8f-be9183044b9a.002.jpeg)

1. **Описание профильной организации** 

ЗАО "ЛИНКС ТЕКНОЛОДЖИС" основано в 2000 году и входит в группу компаний «ААМ Системз», работающих на рынке с 1994 года и занимающих одну  из  лидирующих  позиций  среди  системных  интеграторов,  поставщиков оборудования  и  разработчиков  программного  обеспечения  для  систем технической безопасности. 

"ЛИНКС ТЕКНОЛОДЖИС" имеет собственный серийный программный продукт,  позволяющий  создавать  мощные  интегрированные  системы безопасности, - Программный Комплекс (ПК) LyriX. 

Программный  комплекс  LyriX  является  интеллектуальной  основой современной интегрированной системы безопасности (ИСБ). Его назначение — организация эффективного взаимодействия между различными подсистемами ИСБ и управление ими. 

LyriX  —  это  программный  комплекс  с  удобным  настраиваемым интерфейсом, сочетающий в себе надежность коробочного продукта с гибкостью индивидуального решения. 

Имея  широкий  перечень  реализованных  возможностей,  он  способен решать новые задачи, возникающие с ростом бизнеса заказчика, и работать на любой аппаратно-программной платформе с любым оборудованием, имеющим интерфейс связи с компьютером. 

ПК  LyriX  —  универсальный  инструмент  для  объединения  подсистем безопасности  самых  разных  производителей  в  единый  комплекс.  Его преимущество  заключается  в  гибкой,  настраиваемой,  масштабируемой архитектуре, открытой для сторонних разработчиков 

Благодаря архитектуре ПК LyriX возможно динамическое подключение к нему новых модулей, которые могут не только реализовывать дополнительные функции,  но  и  обеспечивать  подключение  к  ИСБ  нового  оборудования  или программного  обеспечения  (ПО).  Таким  образом,  для  LyriX  не  существует ограничений  по  поддерживаемому  оборудованию  и  по  возможностям интеграции ранее установленных на объекте различных систем безопасности в единый комплекс. 

ПК LyriX — оптимальное решение для крупных и средних предприятий, где требуется мощная централизованная система доступа, охраны и мониторинга систем безопасности. 

2. **Результаты выполнения индивидуального задания** 
1. **Постановка задачи** 

Разработать  небольшую  службу  для  удаленного  администрирования  со следующими функциями: 

- Вывод  списка  служб  и  их  параметров  с  выбранным  статусом выполнения. 
- Изменение статуса выбранного ini-файла. 
- Поиск  log-файлов,  модифицированных  в  заданный  промежуток времени и возврат архива с файлами клиенту. 
- Вывод информации о системе. 
2. **Описание объекта задания** 

Стандартный  пакет  net/http  предоставляет  возможности  реализации клиент-серверной архитектуры и обработки REST-запросов и является наиболее оптимальным  для  решения  простых  задач.  REST-запросы  позволяют эффективно  обмениваться  данными  через  веб-приложение;  все  необходимые данные передаются в качестве параметров запроса. Ajax-запросы организуют кроссдоменное взаимодействие между клиентом и сервером. 

3. **Описание метода решения задачи** 

Создаётся  веб-приложение  с  помощью  стандартного  пакета  net/http. Раздача динамических данных производится с помощью данных в формате json, с  обработкой  через  пакет  encoding/json.  Раздача  статических  данных производится на одном выбранном порту, работа с динамическими данными производится на другом.  

Работа  со  службами  реализуется  с  помощью  пакета  mgr.  Работа  с  ini- файлами  осуществляется  через  пакет  gopkg.in/ini.v1.  Поиск  log-файлов производится с помощью функций библиотеки path/filepath, а их архивирование и отправка – с помощью archive/zip. Вывод информации о системе реализуется через библиотеку gopsutil. 

На клиентской стороне используются шаблоны страниц html и таблицы стилей css. Для реализации кроссдоменных запросов на javascript используются ajax-запросы. 

4. **Экспериментальная часть** 
1) Для  нашего  приложения  создадим  папку  static,  куда  поместим  все 

статические  файлы,  с  которыми  будем  работать.  Затем,  все  запросы, начинающиеся со /static/ будем обрабатывать с помощью FileServer. 

func routes() \*http.ServeMux { 

`   `mux := http.NewServeMux() 

`   `fileServer := http.FileServer(http.Dir("./ui/static/")) 

`   `mux.Handle("/static", http.NotFoundHandler()) 

`   `mux.Handle("/static/", http.StripPrefix("/static", fileServer))    return mux 

} 

Для рендеринга статического содержимого создадим отдельную функцию. 

func render(w http.ResponseWriter, r \*http.Request, name string, td templateData) { 

`   `files := []string{ 

`      `name, 

`      `"./ui/html/base.layout.tmpl", 

`      `"./ui/html/footer.partial.tmpl", 

`   `} 

`   `rs, err := template.ParseFiles(files...) 

`   `if err != nil { 

`      `log.Println(err.Error()) 

`      `http.Error(w, "Internal Server Error", 500)       return 

`   `} 

`   `err = rs.Execute(w, td) 

`   `if err != nil { 

`      `log.Println(err.Error()) 

`      `http.Error(w, "Internal Server Error", 500)    } 

} 

2) Добавим в проект динамики. Свяжем html-страницы с серверной api. Для 

этого будем использовать кроссдоменные ajax-запросы.  

function *Action1Message*() { 

`    `$.ajax({ 

`        `async: true, 

`        `type: 'get', 

`        `url: host + "/api/records",* 
\*
`        `crossDomain: true, 

`        `cache:false, 

`        `dataType: 'json', 

`        `success: function (data, textStatus, jqXHR ){ 

`            `var obj = JSON.parse(jqXHR.responseText); 

`            `document.getElementById("test").innerHTML = obj.title + " " + obj.text; 

`        `}, 

`        `error: function () { 

`            `*alert*('Failed...'); 

`        `} 

`    `}); 

} 

В общем случае, система безопасности браузера предотвращает запросы веб-страницы к другому домену, отличному от того, который обслуживает веб- страницу. Поэтому  обработка  кроссдоменных  запросов  (в  числе  которых запросы  к  другим  портам)  требует  или  включения  на  сервере-ответчике специальных  заголовков  ответа,  или  применения  других  методов  (например, использования  прокси-сервера).  Т.к.  приложение  используется  на  локальном хосте, ограничимся первым вариантом и установим необходимые заголовки: 

w.Header().Set("Access-Control-Allow-Origin", "\*") w.Header().Set("Access-Control-Allow-Methods", "GET, PUT, POST, DELETE, OPTIONS") 

w.Header().Set("Access-Control-Max-Age", "1000") w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X- Requested-With") 

3) Вывод служб 

Для  начала,  создадим  тип,  который  будет  предоставлять  набор необходимой информации о службе. 

type Service struct { 

`   `Name   string        json:"name"  

`   `Config mgr.Config    json:"config"     Status uint32        json:"status"     srv    \*mgr.Service  json:"service"  } 

Для  поиска  служб  будем  использовать  пакет golang.org/x/sys/windows/svc/mgr.  Для  этого  установим  соединение  с диспетчером управления службами. Затем из списка служб, представленных на устройстве,  выберем  нужные,  с  заданным  статусом  и  запросим  у  них необходимые  данные.  Следует  заметить,  что  не  все  службы  могут  быть опрошены, их мы пропускаем. 

func ListServices(get\_status uint32) ([]Service, error) { 

`   `m, err := mgr.Connect() 

`   `defer m.Disconnect() 

`   `if err != nil { 

`      `return nil, errors.New("can't connect to service control manager")    } 

`   `names, err := m.ListServices() 

`   `if err != nil { 

`      `return nil, errors.New("can't get service list") 

`   `} 

`   `var result []Service 

`   `for i := 0; i < len(names); i++ { 

`      `serv, err := m.OpenService(names[i]) 

`      `if err != nil { 

`         `continue 

`      `} 

`      `status, err := serv.Query() 

`      `if err != nil { 

`         `continue 

`      `} 

`      `if uint32(status.State) == get\_status { 

`         `config, err := serv.Config() 

`         `if err != nil { 

`            `continue 

`         `} 

`         `newserv := Service{names[i], config, uint32(status.State), serv}          result = append(result, newserv) 

`      `} 

`   `} 

`   `return result, nil 

} 

Тогда обработчик запроса примет вид: 

func getlist(w http.ResponseWriter, r \*http.Request) { 

`   `switch r.Method { 

`   `case http.MethodPost: 

`      `{ 

`         `body, \_ := ioutil.ReadAll(r.Body) 

`         `var s struct { 

`            `Stat string  json:"status"  

`         `} 

`         `err := json.Unmarshal(body, &s) 

`         `if err != nil { 

`            `w.WriteHeader(500) 

`            `return 

`         `} 

`         `get\_status, err := strconv.Atoi(s.Stat) 

`         `if err != nil { 

`            `w.WriteHeader(500) 

`            `return 

`         `} 

`         `data, err := ListServices(uint32(get\_status)) 

`         `if err != nil { 

`            `w.WriteHeader(500) 

`            `return 

`         `} 

`         `newq, err := json.Marshal(data) 

`         `if err != nil { 

`            `w.WriteHeader(500) 

`            `return 

`         `} 

`         `w.Header().Set("Access-Control-Allow-Origin", "\*") 

`         `w.Header().Set("Access-Control-Allow-Methods", "GET, PUT, POST, DELETE, OPTIONS") 

`         `w.Header().Set("Access-Control-Max-Age", "1000") 

`         `w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With") 

`         `w.Header().Set("Content-Type", "text/html; charset=utf-8") 

`         `w.Write(newq) 

`         `w.WriteHeader(200) 

`      `} 

`   `default: 

`      `{ 

`         `http.Error(w, "Error! Locked.", 423) 

`         `w.WriteHeader(423) 

`         `return 

`      `} 

`   `} 

} 

4) Изменение статуса ini-файла 

Ini-файлы  –  текстовые  файлы  особой  структуры,  содержащие конфигурационные параметры некоторых компонентов ОС Windows. 

INI файл может содержать: 

- пустые строки; 
- [комментарии ](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B9_\(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5\))— от символа «;» (точка с запятой), стоящего в начале строки, до конца строки; 
- заголовки  разделов —  строки,  состоящие  из  названия  раздела, заключённого в квадратные скобки «[ ]»; 
- значения параметров — строки вида «ключ=значение». 

Пример содержимого ini-файла: 

[Options] Enabled   = 1 Brandover = 0 Language  = 1033 SkipUAC   = 1 

[Settings] Display   = 1 Root      = / 

По договоренности, в рамках задачи за статус ini-файла отвечает параметр Enabled  секции  Options.  Функция  обработки  файла  загружает  файл  по переданному имени. Затем извлекает текущий статус файла, заменяет его на противоположный и сохраняет ini-файл. 

func ChangeIni(name string) error { 

`   `cfg, err := ini.Load(name) 

`   `if err != nil { 

`      `return errors.New("can't load ini-file") 

`   `} 

`   `status := cfg.Section("Options").Key("Enabled").Value() 

`   `var new\_status string 

`   `if status == "1" { 

`      `new\_status = "0" 

`   `} else { 

`      `new\_status = "1" 

`   `} 

`   `cfg.Section("Options").Key("Enabled").SetValue(new\_status)    err = cfg.SaveTo(name) 

`   `if err != nil { 

`      `return errors.New("can't save ini-file") 

`   `} 

`   `return nil 

} 

Тогда обработчик примет вид: 

func setini(w http.ResponseWriter, r \*http.Request) {    switch r.Method { 

`   `case http.MethodPost: 

`      `{ 

`         `body, err := ioutil.ReadAll(r.Body) 

`         `if err != nil { 

`            `w.WriteHeader(500) 

`            `return 

`         `} 

`         `var n struct { 

`            `Name string  json:"name"  

`         `} 

`         `err = json.Unmarshal(body, &n) 

`         `if err != nil { 

`            `w.WriteHeader(500) 

`            `return 

`         `} 

`         `err = ChangeIni(n.Name) 

`         `if err != nil { 

`            `w.WriteHeader(500) 

`            `return 

`         `} 

`         `w.Header().Set("Access-Control-Allow-Origin", "\*") 

`         `w.Header().Set("Access-Control-Allow-Methods", "GET, PUT, POST, DELETE, OPTIONS") 

`         `w.Header().Set("Access-Control-Max-Age", "1000") 

`         `w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With") 

`         `w.Header().Set("Content-Type", "text/html; charset=utf-8") 

`         `w.WriteHeader(200) 

`      `} 

`   `default: 

`      `{ 

`         `http.Error(w, "Error! Locked.", 423) 

`         `w.WriteHeader(423) 

`         `return 

`      `} 

`   `} 

} 

5) Поиск log-файлов. Архивирование. 

Сначала создадим архив, в который будем копировать подходящие log- файлы. В качестве имени архива будем использовать текущие дату и время. 

Поиск файлов организуем рекурсивно, с обходом всех файлов и папок внутри заданной директории. Подходящие по времени файлы будем добавлять в архив. 

func listDirByWalk(file\_path string, zip\_path string, t1 time.Time, t2 time.Time) (\*os.File, error) { 

`   `name := time.Now().Format("02012006150405") + ".zip"    outFile, err := os.Create(zip\_path + "\\" + name) 

`   `if err != nil { 

`      `return nil, errors.New("can't create output file")    } 

`   `zipW := zip.NewWriter(outFile) 

`   `filepath.Walk(file\_path, func(wPath string, info os.FileInfo, err error) error { 

`      `if wPath == file\_path { 

`         `return nil 

`      `} 

`      `if info.IsDir() { 

`         `return nil 

`      `} 

`      `if info.ModTime().After(t1) && info.ModTime().Before(t2) { 

`         `dat, \_ := ioutil.ReadFile(wPath) 

`         `f, \_ := zipW.Create(info.Name()) 

`         `f.Write(dat) 

`      `} 

`      `return nil 

`   `}) 

`   `err = zipW.Close() 

`   `if err != nil { 

`      `return nil, errors.New("can't close zip writer")    } 

`   `err = outFile.Close() 

`   `if err != nil { 

`      `return nil, errors.New("can't close output file")    } 

`   `return outFile, nil 

} 

Тогда обработчик примет вид: 

func searchLog(w http.ResponseWriter, r \*http.Request) { 

`   `switch r.Method { 

`   `case http.MethodPost: 

`      `{ 

`         `body, \_ := ioutil.ReadAll(r.Body) 

`         `var dat struct { 

`            `Date\_start string  json:"date\_start"  

`            `Time\_start string  json:"time\_start"  

`            `Date\_end   string  json:"date\_end"  

`            `Time\_end   string  json:"time\_end"  

`         `} 

`         `\_ = json.Unmarshal(body, &dat) 

`         `time\_before, \_ := time.ParseInLocation("2006-01-02 15:04", dat.Date\_start+" "+dat.Time\_start, time.Local) 

`         `time\_after, \_ := time.ParseInLocation("2006-01-02 15:04", dat.Date\_end+" "+dat.Time\_end, time.Local) 

`         `outfile, err := listDirByWalk("\\Документы\\Project\_goland\\logs", "\\Документы\\Project\_goland\\archive", time\_before, time\_after) 

`         `if err != nil { 

`            `w.WriteHeader(500) 

`            `return 

`         `} 

`         `fileBytes, \_ := ioutil.ReadFile(outfile.Name()) 

`         `w.Write(fileBytes) 

`         `w.Header().Set("Access-Control-Allow-Origin", "\*") 

`         `w.Header().Set("Access-Control-Allow-Methods", "GET, PUT, POST, DELETE, OPTIONS") 

`         `w.Header().Set("Access-Control-Max-Age", "1000") 

`         `w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With") 

`         `w.Header().Set("Content-Type", "application/zip") 

`         `w.WriteHeader(200) 

`      `} 

`   `default: 

`      `{ 

`         `http.Error(w, "Error! Locked.", 423) 

`         `w.WriteHeader(423) 

`         `return 

`      `} 

`   `} 

} 

6) Информация о системе. 

Выведем некоторую информацию о системе. Для начала, создадим тип, который будет предоставлять набор необходимой информации о системе. 

type SysInfo struct { 

`   `Hostname string  json:"hostname"     Platform string  json:"platform"     CPU      string  json:"cpu"  

`   `RAM      uint64  json:"ram"  

`   `Disk     uint64  json:"disk"  

} 

Затем используем библиотеку gopsutil для поиска необходимых данных. 

func GetSystemInfo() (SysInfo, error) { 

`   `var info SysInfo 

`   `hostStat, err := host.Info() 

`   `if err != nil { 

`      `return info, errors.New("can't get system host info")    } 

`   `cpuStat, err := cpu.Info() 

`   `if err != nil { 

`      `return info, errors.New("can't get system cpu info") 

`   `} 

`   `vmStat, err := mem.VirtualMemory() 

`   `if err != nil { 

`      `return info, errors.New("can't get system memory info")    } 

`   `diskStat, err := disk.Usage("\\") 

`   `if err != nil { 

`      `return info, errors.New("can't get system disk info")    } 

`   `info.Hostname = hostStat.Hostname 

`   `info.Platform = hostStat.Platform 

`   `info.CPU = cpuStat[0].ModelName 

`   `info.RAM = vmStat.Total / 1024 / 1024    info.Disk = diskStat.Free / 1024 / 1024    return info, nil 

} 

Тогда обработчик запросов примет вид: 

func systemInfo(w http.ResponseWriter, r \*http.Request) { 

`   `switch r.Method { 

`   `case http.MethodGet: 

`      `{ 

`         `info, err := GetSystemInfo() 

`         `if err != nil { 

`            `w.WriteHeader(500) 

`            `return 

`         `} 

`         `data, err := json.Marshal(info) 

`         `if err != nil { 

`            `w.WriteHeader(500) 

`            `return 

`         `} 

`         `w.Write(data) 

`         `w.Header().Set("Access-Control-Allow-Origin", "\*") 

`         `w.Header().Set("Access-Control-Allow-Methods", "GET, PUT, POST, DELETE, OPTIONS") 

`         `w.Header().Set("Access-Control-Max-Age", "1000") 

`         `w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With") 

`         `w.WriteHeader(200) 

`      `} 

`   `default: 

`      `{ 

`         `http.Error(w, "Error! Locked.", 423)          w.WriteHeader(423) 

`         `return 

`      `} 

`   `} 

} 

5. **Выводы** 

Поставленная  задача  выполнена.  Служба  предоставляет  заявленный функционал. 

**Список литературы** 

1. Обработка статических данных // Golangify URL: [https://golangify.com/serving-static-files ](https://golangify.com/serving-static-files)
1. Хабр: [сайт] URL:[ https://habr.com/ru/company/ruvds/blog/559816/ ](https://habr.com/ru/company/ruvds/blog/559816/)- Перевод статьи:[ Разработка REST-серверов на Go. Часть 1: стандартная библиотека ](https://habr.com/ru/company/ruvds/blog/559816/)
1. jQuery [сайт] URL:[ https://api.jquery.com/jquery.ajax/ ](https://api.jquery.com/jquery.ajax/)- jQuery API ajax Documentation 
1. Блог о языке программирования Go [сайт] URL:[ https://golang- blog.blogspot.com/2019/11/json-golang.html ](https://golang-blog.blogspot.com/2019/11/json-golang.html)- Работа с json в Golang 
1. HTML5BOOK [сайт] URL:[ https://html5book.ru/ ](https://html5book.ru/)- Основы HTML, основы CSS 
1. Максим Жашкевич Язык Go для начинающих. - 1-е изд. - 2020. - 109 с. 

**Выполненная производственная работа** 

Разработано  веб-приложение  в  соответствии  с  поставленной  задачей. Обработка запросов осуществляется на сервере на отдельном порте. Обработка статических  данных  и  обмен  данными  с  пользователем  –  на  другом  порте. Обеспечено кроссдоменное взаимодействие между клиентом и сервером. Для лучшего  визуального  восприятия  на  клиентской  стороне  использованы  html- шаблоны страниц и таблицы стилей  css. Для динамичности добавлен код на javascript. Приложение успешно протестировано. 

10 
**Заключение** 

В результате прохождения практики были получены знания о разработке веб-сервисов, REST-запросах;  укреплён навык  в программировании  на языке Golang. Получены базовые знания написания html-страниц, css-файлов. А также базовые знания javascript, ajax-запросов. 
11 
